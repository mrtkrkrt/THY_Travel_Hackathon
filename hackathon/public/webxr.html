<html lang="en">
  <head>
    <title>Basic Scene with WebXR</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <link type="text/css" rel="stylesheet" href="./webxrStyles.css" />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.js"
      crossorigin="anonymous"
    ></script>
    <script src="https://r105.threejsfundamentals.org/threejs/resources/threejs/r105/js/controls/OrbitControls.js"></script>
    <script src="https://r105.threejsfundamentals.org/threejs/resources/threejs/r105/js/loaders/LoaderSupport.js"></script>
    <script src="https://r105.threejsfundamentals.org/threejs/resources/threejs/r105/js/loaders/OBJLoader2.js"></script>
    <script src="https://r105.threejsfundamentals.org/threejs/resources/threejs/r105/js/loaders/MTLLoader.js"></script>
  </head>

  <body>
    <div>latitude:<span id="latitude"></span></div>
    <div>longitude:<span id="longitude"></span></div>
    <div>webxr-camera-z:<span id="webxrcameraz"></span></div>
    <div>test:<span id="test"></span></div>
    <script type="module">
      // To start an AR scene with webXR, we can use a handy button provided by three.js
      // We first have to import it because it is a javascript module
      import { ARButton } from "https://unpkg.com/three@0.126.0/examples/jsm/webxr/ARButton.js";

      let camera, scene, renderer;
      let mesh;
      let root;
      let time;
      let cameraVector = new THREE.Vector3(); 

      init();
      animate();

      const latitudeElem = document.querySelector("#latitude");
      const longitudeElem = document.querySelector("#longitude");
      const zElem = document.querySelector("#webxrcameraz");
      const testElem = document.querySelector("#test");

      function init() {
        time = new Date();
        const container = document.createElement("div");
        document.body.appendChild(container);

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          40
        );
        const controls = new THREE.OrbitControls(camera, container);
        controls.target.set(0, 5, 0);
        controls.update();

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        // This next line is important to to enable the renderer for WebXR
        renderer.xr.enabled = true; // New!
        container.appendChild(renderer.domElement);

        var light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);

        function frameArea(sizeToFitOnScreen, boxSize, boxCenter, camera) {
          const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
          const halfFovY = THREE.Math.degToRad(camera.fov * 0.5);
          const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
          // compute a unit vector that points in the direction the camera is now
          // in the xz plane from the center of the box
          const direction = new THREE.Vector3()
            .subVectors(camera.position, boxCenter)
            .multiply(new THREE.Vector3(1, 0, 1))
            .normalize();

          // move the camera to a position distance units way from the center
          // in whatever direction the camera was from the center already
          camera.position.copy(
            direction.multiplyScalar(distance).add(boxCenter)
          );

          // pick some near and far values for the frustum that
          // will contain the box.
          camera.near = boxSize / 100;
          camera.far = boxSize * 100;

          camera.updateProjectionMatrix();

          // point the camera to look at the center of the box
          camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
        }

        const objLoader = new THREE.OBJLoader2();
        objLoader.loadMtl("./arrow.mtl", null, (materials) => {
          objLoader.setMaterials(materials);
          objLoader.load("./arrow.obj", (event) => {
            root = event.detail.loaderRootNode;
            root.scale.x = 0.3;
            root.scale.y = 0.3;
            root.scale.z = 0.3;
            root.position.z = -1;
            root.position.y = -0.5;
            root.rotation.x = (Math.PI / 180) * 80;
            
            
            camera.updateMatrixWorld();
            var vector = camera.position.clone();
            vector.applyMatrix4( camera.matrixWorld );
            
            console.log(vector);
            scene.add(root);

            // compute the box that contains all the stuff
            // from root and below
            const box = new THREE.Box3().setFromObject(root);

            const boxSize = box.getSize(new THREE.Vector3()).length();
            const boxCenter = box.getCenter(new THREE.Vector3());

            // set the camera to frame the box
            frameArea(boxSize * 1.2, boxSize, boxCenter, camera);

            // update the Trackball controls to handle the new size
            controls.maxDistance = boxSize * 10;
            controls.target.copy(boxCenter);
            controls.update();
          });
        });

        // Add the AR button to the body of the DOM
        document.body.appendChild(ARButton.createButton(renderer));

        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render(timestamp, frame) {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(function showPosition(
            position
          ) {
            latitudeElem.textContent = position.coords.latitude;
            longitudeElem.textContent = position.coords.longitude;
          });
        }

        if (frame) {
          let time2 = new Date();
          let a = (time2 - time) / 1000;
          if (a > 0.01) {
            time = new Date();
            
            let xrCamera = renderer.xr.getCamera(camera);
            var xrVector = xrCamera.position.clone();
            xrVector.applyMatrix4( xrCamera.matrixWorld );
            
            let e = xrCamera.matrixWorld.elements;
            let direction = new THREE.Vector3(-e[8], -e[9], -e[10]);
            root.position.x = direction.x;
            root.position.y = direction.y;
            
            
            root.position.z = xrVector.z - 1
            
            zElem.textContent = JSON.stringify(xrVector);
          }

          
        }
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>